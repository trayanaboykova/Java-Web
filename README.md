# Spring Fundamentals
Tasks from my course Spring Fundamentals at <a href="https://softuni.bg/">SoftUni</a> 

<b> Course Curriculum: <a href="https://softuni.bg/trainings/4843/spring-fundamentals-january-2025">Spring Fundamentals</a> </b>

**[HTTP Protocol](https://github.com/trayanaboykova/Spring-Fundamentals/tree/main/HTTP%20Protocol/java-web-http-protocol-demo-master)**: <br>
In this lesson, I learned about the HTTP protocol and how it plays a fundamental role in web applications. I explored the concept of embedded web servers and gained an understanding of how HTTP facilitates communication between clients and servers through requests and responses. I also studied different HTTP methods, such as GET, POST, PUT, and DELETE, and learned about the importance of idempotency in ensuring safe and predictable operations. Additionally, I covered MIME types, which help the server and client understand the nature of the data being exchanged.

**Spring Core**: <br>
In this lesson, I was introduced to the core concepts of the Spring framework and learned how Spring Boot simplifies the development of Spring-based applications. I explored the principles of Inversion of Control (IoC) and Dependency Injection, which allow for better flexibility and decoupling of components in an application. I also learned about Spring Beans, their lifecycle, and how they are managed by the Spring IoC container. Additionally, I studied the layered architecture approach commonly used in Spring applications to separate concerns and improve maintainability.

**Spring MVC with Thymeleaf Basics**: <br>
In this lesson, I learned about the Model-View-Controller (MVC) architecture, which is a widely used pattern for structuring web applications. The MVC design pattern separates the application into three main components: the model (business logic and data), the view (user interface), and the controller (handles requests and user input). I explored how Spring MVC applies this architecture to develop scalable and maintainable web applications. Additionally, I was introduced to Thymeleaf, a templating engine for Java that integrates seamlessly with Spring MVC to render dynamic web pages. I learned how to use Thymeleaf to build views by embedding expressions, conditionals, and loops directly into HTML templates, improving the development process by allowing for clean and readable templates.

**Spring MVC with Thymeleaf Advanced**: <br>
In this lesson, I delved deeper into Spring MVC and Thymeleaf, focusing on more advanced topics. First, I learned about Form Handling and Data Binding in Spring MVC, which allows for easy submission and processing of form data. I explored how Spring automatically binds form data to Java objects and how to handle form submissions using `@ModelAttribute` and `@RequestMapping`. This process simplifies the management of user input in web applications. I also studied Validation with Thymeleaf, where I learned how to implement server-side validation for form data using JSR-303 annotations (such as `@NotNull`, `@Size`, etc.) and how to integrate this with Thymeleaf to provide user-friendly error messages. Finally, I explored Thymeleaf Utilities, which include helpful functions for working with data in templates, such as formatting dates, handling numbers, and dynamically generating URLs, which greatly improve the flexibility and usability of Thymeleaf templates in complex applications.

**State Management**: <br>
In this lesson, I explored the concept of state management in web applications, focusing on how to maintain and manage the state of a user's interaction across multiple requests. I started with HTTP Cookies, learning how cookies are small pieces of data stored on the client side that can be sent back to the server with subsequent requests. I studied how to set, retrieve, and delete cookies in a Spring-based application. Next, I covered HTTP Sessions, which allow for server-side storage of user-specific data across multiple requests. I learned how to use the `HttpSession` object to store and retrieve session data, ensuring that each user can have a personalized experience. I also learned about Working with HTTP Sessions, Cookies, and Headers, where I explored how to manage both cookies and sessions in the context of HTTP headers, and how these headers can be used for controlling the state of the user's session or for security purposes (e.g., setting the `HttpOnly` flag for cookies). Finally, I was introduced to Servlet Interceptors, which are used to intercept and manipulate HTTP requests and responses before they reach the controller or after the controller has processed them. I learned how interceptors can be used for tasks like logging, performance monitoring, or modifying request/response headers.

**Events, Scheduling Tasks and Caching**: <br>
In this lesson, I learned how to implement and manage events, scheduled tasks, and caching in Spring applications to improve functionality and performance. First, I explored Spring Events, which allow components to communicate by publishing and listening to events within an application. I learned how to define custom events and listeners and how to use the `ApplicationEventPublisher` to publish events across the Spring context, allowing for decoupled communication between components. Next, I delved into Scheduling Tasks, where I learned how to use Spring’s scheduling support to run tasks at fixed intervals or at specific times using annotations like `@Scheduled`. I also explored how to configure scheduling through XML or Java configuration to automate repetitive tasks, such as background jobs or cleanup tasks. Finally, I covered Caching, an essential technique to enhance performance by storing the results of expensive operations in memory. I learned how to implement caching with Spring using the `@Cacheable`, `@CachePut`, and `@CacheEvict annotations`. This allows applications to avoid recalculating values and reduce the load on databases or external services by reusing previously computed results.

# Spring Advanced
Tasks from my course Spring Fundamentals at <a href="https://softuni.bg/">SoftUni</a> 

<b> Course Curriculum: <a href="https://softuni.bg/trainings/4844/spring-advanced-february-2025">Spring Advanced</a> </b>

**Spring Security**: <br>
In this lesson, I explored the fundamentals of Spring Security, a robust framework designed to secure Java web applications. I started with an introduction to the core concepts of security and learned how to configure Spring Security to protect endpoints and manage authentication and authorization. I delved into implementing custom user authentication by working with the UserDetailsService and UserDetails interfaces, which allow for flexible retrieval and management of user data. Additionally, I examined method-level security to restrict access via annotations and learned how filters can intercept HTTP requests to enforce security policies. This comprehensive overview equips me with the essential tools to build secure and reliable applications.

**REST API and REST with Spring**: <br>
In this lesson, I learned the principles of Representational State Transfer (REST) and what makes an API RESTful, including statelessness, resource-based URIs, and the uniform interface constraints. I studied the six REST constraints (client-server separation, stateless interactions, cacheable responses, uniform interface, layered system architecture, and code on demand) and how adhering to them leads to scalable, maintainable APIs. Then, using Spring Boot, I built RESTful endpoints with `@RestController`, leveraged `ResponseEntity` for flexible response handling, and managed content negotiation via HTTP status codes and headers. I also explored best practices for designing resource URIs, versioning APIs, and documenting endpoints with Swagger/OpenAPI.

**Microservice Architecture**: <br>
This lesson introduced the microservices architectural style as an alternative to the monolithic approach. I compared the advantages and trade-offs of monoliths (single deployable unit, simpler testing) versus microservices (independent deployment, horizontal scalability, technological heterogeneity). I learned how to decompose a system into bounded-context services, how to manage inter-service communication, and the role of service discovery and configuration management. Finally, I worked with OpenFeign to create declarative REST clients for RPC-style communication between microservices, simplifying HTTP calls with interface-based clients and load-balancing support.

**Exception Handling**: <br>
In this lesson, I explored robust error management in Spring MVC and REST applications. I learned about local exception handling with `@ExceptionHandler` methods within controllers, and global handling using `@ControllerAdvice` classes to centralize error responses. For REST APIs, I practiced crafting consistent error payloads (including timestamps, status codes, and human-readable messages) and setting appropriate HTTP statuses. I also saw how to combine validation errors from JSR-303 (e.g. `@Valid`, `@NotNull`) into custom error responses, ensuring clients receive clear feedback on invalid input.

**Unit Testing**: <br>
This lesson covered writing automated unit tests for Spring components. I learned how to use JUnit 5 to structure tests and Mockito to mock dependencies, applying `@Mock` to create mock instances and @InjectMocks to inject them into the class under test. I practiced testing service and repository layers in isolation, verifying behavior with Mockito’s `when(...).thenReturn(...)` and `verify(...)` methods. Emphasis was placed on testing business logic without starting the Spring context, ensuring tests ran quickly and deterministically.

**Integration and API Testing**: <br>
I learned how to test the full application stack end-to-end. Using `@SpringBootTest`, I started the Spring context and embedded server, then used `TestRestTemplate` (or `WebTestClient` in reactive apps) to call real HTTP endpoints and assert responses. I also practiced using `MockMvc` for lightweight controller tests without a running server, simulating requests and validating JSON payloads, headers, and status codes. This ensured that controllers, filters, exception handlers, and serialization all worked as expected.

**Aspect-Oriented Programming (AOP)**: <br>
In this lesson, I explored AOP as a way to factor out cross-cutting concerns (such as logging, security checks, or transaction management) from core business logic. I studied key terminology—join points (where advice applies), pointcuts (expressions selecting join points), advice types (before, after, around, after-returning, after-throwing), and aspects (modules combining pointcuts and advice). I practiced writing `@Aspect` classes with `@Pointcut` expressions using AspectJ syntax and applied `@Before`, `@AfterReturning`, and `@Around` advice to measure method execution times and perform authorization checks transparently.

**Introduction to Cloud**: <br>
This lesson provided an overview of cloud computing concepts and how to containerize Spring applications. I learned the basics of IaaS, PaaS, and SaaS models, and then moved on to Docker: writing `Dockerfiles`, building images, and running containers locally. I saw how Docker Compose can orchestrate multi-container setups (e.g., app + database). Finally, I integrated Swagger (OpenAPI) into my Spring projects with `springdoc-openapi` to auto-generate interactive API documentation, allowing clients to explore and test endpoints directly in the browser.

**Spring for Apache Kafka**: <br>
In this lesson, I was introduced to Apache Kafka as a distributed streaming platform and learned how to integrate it with Spring. I configured Kafka producers and consumers using `spring-kafka`, working with `KafkaTemplate` to send messages and `@KafkaListener` to receive them. I studied topic creation, partitioning, and consumer groups for scalability and fault tolerance. I also learned how to serialize and deserialize messages (e.g., JSON, Avro) and how to handle listener errors and retries, enabling reliable event-driven communication in microservices.
